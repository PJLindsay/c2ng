/**
  *  \file u/t_ui_res_ccimageloader.cpp
  *  \brief Test for ui::res::CCImageLoader
  */

#include "ui/res/ccimageloader.hpp"

#include "t_ui_res.hpp"
#include "afl/io/constmemorystream.hpp"
#include "gfx/types.hpp"

/** Load a compressed ".cd" image. */
void
TestUiResCCImageLoader::testCompressedCD()
{
    // share/resource/ui/cb0.cd
    static const uint8_t IMAGE[] = {
        0xc6, 0x01, 0x00, 0x00, 0xc6, 0x01, 0xff, 0x43, 0x44, 0x10, 0x00, 0x10,
        0xff, 0xc1, 0x00, 0x37, 0xff, 0x0e, 0x00, 0x37, 0x00, 0xff, 0x0e, 0x3d,
        0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00,
        0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e,
        0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f,
        0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff,
        0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x00, 0xff, 0x0e, 0x3d,
        0x0f, 0x00, 0xff, 0x0e, 0x3d, 0x0f, 0x37, 0xff, 0x0e, 0x0f, 0x3e, 0x00,
        0x00
    };
    afl::io::ConstMemoryStream ms(IMAGE);
    ui::res::CCImageLoader testee;

    // Load it
    afl::base::Ptr<gfx::Canvas> can(testee.loadImage(ms));
    TS_ASSERT(can.get() != 0);
    TS_ASSERT_EQUALS(can->getSize().getX(), 16);
    TS_ASSERT_EQUALS(can->getSize().getY(), 16);

    // Verify some pixels
    gfx::Color_t color[1];
    gfx::ColorQuad_t quad[1];
    can->getPixels(gfx::Point(0, 0), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(125, 125, 125));

    can->getPixels(gfx::Point(1, 0), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(0, 0, 0));

    can->getPixels(gfx::Point(1, 1), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(222, 222, 222));

    can->getPixels(gfx::Point(10, 10), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(222, 222, 222));
}

/** Test an uncompressed ".gfx" image. */
void
TestUiResCCImageLoader::testUncompressedGFX()
{
    // share/resource/ui/radio0.gfx
    static const uint8_t IMAGE[] = {
        0x00, 0x08, 0x14, 0x00, 0x14, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x20, 0x20,
        0x20, 0x20, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x20, 0x20, 0x18, 0x1d, 0x1d, 0x1d, 0x1d, 0x17, 0x20,
        0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x17, 0x20, 0x17,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x20, 0x01, 0x17, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x20, 0x17, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0x20, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f,
        0xff, 0xff, 0xff, 0x20, 0x18, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0x20,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0x20, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x0f, 0xff, 0xff, 0x20, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0x20,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0x20, 0x18, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x0f, 0xff, 0xff, 0xff, 0x20, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0xff, 0xff,
        0x20, 0x17, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0x20, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x17, 0x20, 0x01, 0x1d, 0x1d, 0x1d, 0x1d,
        0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f, 0x1d, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0x17, 0x01, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x0f,
        0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    };

    afl::io::ConstMemoryStream ms(IMAGE);
    ui::res::CCImageLoader testee;

    // Load it
    afl::base::Ptr<gfx::Canvas> can(testee.loadImage(ms));
    TS_ASSERT(can.get() != 0);
    TS_ASSERT_EQUALS(can->getSize().getX(), 20);
    TS_ASSERT_EQUALS(can->getSize().getY(), 20);

    // Verify some pixels
    gfx::Color_t color[1];
    gfx::ColorQuad_t quad[1];
    can->getPixels(gfx::Point(0, 0), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(ALPHA_FROM_COLORQUAD(quad[0]), 0U);

    can->getPixels(gfx::Point(10, 10), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(222, 222, 222));

    can->getPixels(gfx::Point(10, 18), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(255, 255, 255));
}

/** Test a compressed ".cc" file. */
void
TestUiResCCImageLoader::testCompressedCC()
{
    // PCC1: cc/res/cb-cond.cc
    static const uint8_t IMAGE[] = {
        0x95, 0x00, 0x00, 0x00, 0x95, 0x00, 0xfe, 0x43, 0x43, 0x10, 0x00, 0x10,
        0xfe, 0x18, 0x00, 0x20, 0xfe, 0x06, 0x22, 0xf2, 0x20, 0xfe, 0x06, 0x22,
        0xf2, 0x20, 0x22, 0x22, 0x55, 0x55, 0x25, 0x22, 0xf2, 0x20, 0x22, 0x52,
        0xfe, 0x03, 0x55, 0x22, 0xf2, 0x20, 0x22, 0x55, 0x25, 0x22, 0x55, 0x25,
        0xf2, 0x20, 0x22, 0x55, 0x22, 0x22, 0x52, 0x22, 0xf2, 0x20, 0x22, 0x55,
        0xfe, 0x04, 0x22, 0xf2, 0x20, 0x22, 0x55, 0xfe, 0x04, 0x22, 0xf2, 0x20,
        0x22, 0x55, 0x22, 0x22, 0x52, 0x22, 0xf2, 0x20, 0x22, 0x55, 0x25, 0x22,
        0x55, 0x25, 0xf2, 0x20, 0x22, 0x52, 0xfe, 0x03, 0x55, 0x22, 0xf2, 0x20,
        0x22, 0x22, 0x55, 0x55, 0x25, 0x22, 0xf2, 0x20, 0xfe, 0x06, 0x22, 0xf2,
        0x20, 0xfe, 0x06, 0x22, 0xf2, 0xf0, 0xfe, 0x07, 0xff, 0x00, 0x00
    };

    afl::io::ConstMemoryStream ms(IMAGE);
    ui::res::CCImageLoader testee;

    // Load it
    afl::base::Ptr<gfx::Canvas> can(testee.loadImage(ms));
    TS_ASSERT(can.get() != 0);
    TS_ASSERT_EQUALS(can->getSize().getX(), 16);
    TS_ASSERT_EQUALS(can->getSize().getY(), 16);

    // Verify some pixels
    gfx::Color_t color[1];
    gfx::ColorQuad_t quad[1];
    can->getPixels(gfx::Point(0, 0), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(0, 0, 0));

    can->getPixels(gfx::Point(15, 15), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(255, 255, 255));

    can->getPixels(gfx::Point(6, 3), color);
    can->decodeColors(color, quad);
    TS_ASSERT_EQUALS(quad[0], COLORQUAD_FROM_RGB(64, 129, 64));
}

